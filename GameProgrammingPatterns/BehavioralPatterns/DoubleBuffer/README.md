# 双缓冲模式
## 意图
用序列操作模拟瞬间或者同时发生的事情。

## 要点
- 定义缓冲类封装缓冲：一段可改变的状态。这个缓冲被增量地修改，但我们想要外部的代码将批量的修改视为单一的原子操作。 为了实现这点，类保存了两个缓冲的实例：下一缓冲和当前缓冲。
- 数据从当前缓冲读取，向下一个缓冲写入。当改变完成后，一个交换操作会立刻将当前缓冲区和下一缓冲区交换（通常仅需要交换两个缓冲区的指针即可）， 这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。

## 使用场景
- 需要维护一些被增量修改的状态。
- 在修改过程中，状态可能会被外部请求。
- 防止请求状态的外部代码知道内部的工作方式。
- 读取状态时，不想等待修改完成。

## 设计决策
- **交换缓冲区方式**
  - 交换缓冲区引用或指针
      - 速度快，只需改变指针的指向。
      - 外部代码获取缓冲区的指针有时效性。
      - 缓冲区中的数据是两帧之前的数据，而不是上一帧的数据。当绘制第三帧的数据时，当前缓冲区是第一帧的数据，此时会丢失第二帧的数据。
  - 在缓冲区间拷贝数据
      - 下一帧的数据和之前的数据相差一帧。
      - 交换可能更耗时。
- **缓冲的粒度**
    - 一整块缓存

        交换操作更简单。 由于只有一对缓存，一个简单的交换就完成了。
    - 每个对象一块缓存

        交换操作更慢。 为了交换，需要遍历整个对象集合，通知每个对象交换。


        
#### 参考文献
http://gameprogrammingpatterns.com/contents.html  《Game Programming Patterns》
